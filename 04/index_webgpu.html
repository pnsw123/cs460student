<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Default WebGL!</title>
    <style>
      html, body { 
        background-color:#000;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important; 

        /* Part 10 + Bonus: Add a customized background!  */
        background: url("./photos/spongbob.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <script type="module">

      async function main() {
        // 1) WebGPU init
        if (!navigator.gpu) throw new Error("WebGPU not supported on this browser.");
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) throw new Error("No appropriate GPUAdapter found.");
        const device = await adapter.requestDevice();


        const canvas = document.getElementById('c');
        const context = canvas.getContext('webgpu'); // setup WebGPU context
        const format  = navigator.gpu.getPreferredCanvasFormat();


        // resize() function was generated by AI, I coudn't get my original per fish movment code to work at all.
        // I tried using below block of code from index.html, but it didn't work at all, spent hours on this and ended up using AI for 
        // better smooother movements
        /*   
         " for (var i = 0; i < all_fish.length; i++){ 
        fishState.push({ // this part is the bonus part, it adds state to each fish for movement
          vx: (Math.random()*0.004 + 0.003) * (Math.random()<0.5?-1:1), // gentle horizontal drift
          phase: Math.random()*Math.PI*2,                                // for sinusoidal wiggle
          wiggleAmp: 0.015 + Math.random()*0.015,                        // vertical amplitude
          speed: 0.9 + Math.random()*0.6                                 // individual wiggle speed
          });
      }*/

        
        function resize() {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          canvas.width  = Math.floor(dpr * innerWidth);
          canvas.height = Math.floor(dpr * innerHeight);
          context.configure({ device, format, alphaMode:'premultiplied' });
        }
        resize();
        addEventListener('resize', resize);

        // 2) Shaders
        // shared block is fully AI generated, I coudn't get the starter code working. Even HW4 regular shaders don't work here.
        const wgsl = {
          fish: `
            struct Uniforms {
              transform: mat4x4<f32>,  // 64
              color: vec4<f32>,        // 16
              eye_direction: f32,      // 4
              point_size: f32,         // 4
              pad: vec2<f32>,          // 8 -> total 96 (multiple of 16)
            };
            @group(0) @binding(0) var<uniform> U: Uniforms;

            @vertex
            fn vs_main(@location(0) position: vec3<f32>) -> @builtin(position) vec4<f32> {
              return U.transform * vec4<f32>(position, 1.0);
            }

            @fragment
            fn fs_main() -> @location(0) vec4<f32> {
              return U.color;
            }
          `,
          eye: `
            struct Uniforms {
              transform: mat4x4<f32>,
              color: vec4<f32>,
              eye_direction: f32,
              point_size: f32,
              pad: vec2<f32>,
            };
            @group(0) @binding(0) var<uniform> U: Uniforms;

            @vertex
            fn vs_main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
              // 2 triangles making a unit quad
              let quad = array<vec2<f32>,6>(
                vec2<f32>(-0.5,-0.5), vec2<f32>( 0.5,-0.5), vec2<f32>(-0.5, 0.5),
                vec2<f32>(-0.5, 0.5), vec2<f32>( 0.5,-0.5), vec2<f32>( 0.5, 0.5)
              );
              let eye_model = vec3<f32>(0.2, 0.2 * U.eye_direction, 0.0);
              let p = vec3<f32>(
                quad[vid].x * U.point_size + eye_model.x,
                quad[vid].y * U.point_size + eye_model.y,
                eye_model.z
              );
              return U.transform * vec4<f32>(p, 1.0);
            }

            @fragment
            fn fs_main() -> @location(0) vec4<f32> {
              return vec4<f32>(0.0, 0.0, 0.0, 0.7);
            }
          `
        };

        const fishModule = device.createShaderModule({ code: wgsl.fish });
        const eyeModule  = device.createShaderModule({ code: wgsl.eye });

        const bgl = device.createBindGroupLayout({
          entries: [{ binding:0, visibility: GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT, buffer:{ type:'uniform' } }]
        });
        const layout = device.createPipelineLayout({ bindGroupLayouts:[bgl] });


        // below block is mixed of my orginal solution from index.html, CoPilot and starter code
        const fishPipeline = device.createRenderPipeline({
          layout,
          vertex: {
            module: fishModule,
            entryPoint: 'vs_main',
            buffers: [{ arrayStride: 12, attributes:[{ shaderLocation:0, offset:0, format:'float32x3' }] }]
          },
          fragment: {
            module: fishModule,
            entryPoint: 'fs_main',
            targets: [{
              format,
              blend: {
                color: { srcFactor:'src-alpha', dstFactor:'one-minus-src-alpha', operation:'add' },
                alpha: { srcFactor:'one',       dstFactor:'one-minus-src-alpha', operation:'add' }
              }
            }]
          },
     
        });

        const eyePipeline = device.createRenderPipeline({
          layout,
          vertex: { module: eyeModule, entryPoint:'vs_main' },
          fragment:{ module: eyeModule, entryPoint:'fs_main', targets:[{
            format,
            blend: {
              color: { srcFactor:'src-alpha', dstFactor:'one-minus-src-alpha', operation:'add' },
              alpha: { srcFactor:'one',       dstFactor:'one-minus-src-alpha', operation:'add' }
            }
          }]},
        });

        // 3) Geometry
        const vertices = new Float32Array([
          0.5,  0.0, 0.0,
          0.2,  0.25,0.0,
         -0.2,  0.15,0.0,
         -0.4,  0.3, 0.0,
         -0.4, -0.3, 0.0,
         -0.2, -0.15,0.0,
          0.2, -0.25,0.0
        ]);
        const indices = new Uint32Array([ 0,1,6, 1,2,6, 2,5,6, 2,3,5, 3,4,5 ]);

        const vbuf = device.createBuffer({ size: vertices.byteLength, usage: GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST, mappedAtCreation:true });
        new Float32Array(vbuf.getMappedRange()).set(vertices); vbuf.unmap();

        const ibuf = device.createBuffer({ size: indices.byteLength, usage: GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST, mappedAtCreation:true });
        new Uint32Array(ibuf.getMappedRange()).set(indices); ibuf.unmap();

        // 4) Fish state + uniforms (ported logic)
        const uniformBytes = 96; // matches WGSL struct (see comments above)
        function makeFish(offset, color, scale=1, direction=1){
          const uniformBuffer = device.createBuffer({ size:uniformBytes, usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST });
          const bindGroup = device.createBindGroup({ layout:bgl, entries:[{ binding:0, resource:{ buffer:uniformBuffer } }] });
          return {
            offset: Float32Array.from(offset),
            color:  Float32Array.from(color),
            scale, direction, uniformBuffer, bindGroup,
            state: {
              vx:(Math.random()*0.004+0.003)*(Math.random()<0.5?-1:1),
              phase:Math.random()*Math.PI*2,
              wiggleAmp:0.015+Math.random()*0.015,
              speed:0.9+Math.random()*0.6
            }
          };
        }
        
        const keys = {};
        addEventListener('keydown', e => { keys[e.code] = true; });
        addEventListener('keyup',   e => { keys[e.code] = false; });

        const all_fish = [];
        all_fish.push(makeFish([0,0,0],[1.00,0.90,0.20,0.90],1,-1));
        for(let i=0;i<100;i++){
            // mostly same logic from index.html
          const rc=[Math.random(),Math.random(),Math.random(),0.8];
          const ro=[Math.random()-Math.random(),Math.random()-Math.random(),0];
          const sc=Math.random()*0.3;
          all_fish.push(makeFish(ro,rc,sc,1));
        }

        // GPT part
        function updateFish(f, idx, t){
          if(idx===0){
            const speed=0.025;
            if(keys['KeyA']){ f.offset[0]-=speed; f.direction=-1; }
            if(keys['KeyD']){ f.offset[0]+=speed; f.direction= 1; }
            if(keys['KeyW']) f.offset[1]+=speed;
            if(keys['KeyS']) f.offset[1]-=speed;
            f.offset[0]=Math.max(-1.25,Math.min(1.25,f.offset[0]));
            f.offset[1]=Math.max(-1.25,Math.min(1.25,f.offset[1]));
          }else{
            f.offset[0]+=f.state.vx;
            f.offset[1]=f.offset[1]+f.state.wiggleAmp*0.1*Math.sin(f.state.speed*t+f.state.phase);
            if(f.offset[0]> 1.25) f.offset[0]=-1.25;
            if(f.offset[0]<-1.25) f.offset[0]= 1.25;
          }

          const a=0.65+0.25*Math.sin(t*1.8);
          if(idx!==0){
            const warm=[ 
            0.98, 0.58,0.42,
            0.95,0.76,0.30,
            0.92,0.48,0.60,
            0.70,0.90,0.70 ];


            const k=((idx-1)%4)*3;
            f.color.set([warm[k],warm[k+1],warm[k+2],a]);
          }else{
            f.color.set([1.00,0.90,0.20,0.90]);
          }
        }

        // 5) Render loop
        function frame(){
          const t=performance.now()*0.001;

          // Update uniforms for each fish
          for(let i=0;i<all_fish.length;i++){
            const f=all_fish[i];
            updateFish(f,i,t);

            
            const sx = f.direction * f.scale, sy = f.scale, sz = f.scale;
            const transform = new Float32Array([ // mixed between GPT,  and my solutions in index.html 
              sx, 0,  0,  0,
              0,  sy, 0,  0,
              0,  0,  sz, 0,
              f.offset[0], f.offset[1], f.offset[2]||0, 1
            ]);

            // Pack uniforms (96 bytes / 24 floats) . 
            const U = new Float32Array(24);
            U.set(transform, 0);        
            U.set(f.color, 16);      
            U[20] = f.direction;           
            U[21] = f.scale * 0.030;         
           

            device.queue.writeBuffer(f.uniformBuffer, 0, U);
          }

          const encoder = device.createCommandEncoder();
          const view = context.getCurrentTexture().createView();
          const pass = encoder.beginRenderPass({
            colorAttachments:[{
              view,
              clearValue:{r:0,g:0,b:0,a:0}, 
              loadOp:'clear',
              storeOp:'store'
            }]
          });

          // Draw all fish bodies
          pass.setVertexBuffer(0, vbuf);
          pass.setIndexBuffer(ibuf, 'uint32');

          for(const f of all_fish){
            pass.setBindGroup(0, f.bindGroup);
            pass.setPipeline(fishPipeline);
            pass.drawIndexed(indices.length);

            pass.setPipeline(eyePipeline);
            pass.draw(6);
          }

          pass.end();
          device.queue.submit([encoder.finish()]);
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      }

      
      window.onload = () => {
        main().catch(err => {
          console.error(err);
          document.body.innerHTML = `<div style="text-align:center;color:white;padding:20px;">
            <h1>Error</h1><p>${err.message}</p>
        
            <p>Please ensure youâ€™re on a WebGPU-compatible browser (like Chrome/Edge, up to date).</p>
          </div>`;
        });
      };
    </script>
  </body>
</html>
